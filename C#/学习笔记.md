[TOC]
# 面向过程
## 1.科学计数法
浮点数后面可以用"e"指示10的指数:
float f1=35e3F;
double d1=12E4D;
## 2.Math
### ==Math.Sqrt(x)==    
若x为64,则输出为8
### ==Math.Abs(x)==
输出为x的绝对值
### ==Math.Round(9.99)==   
 10
### ==Math.Round(9.5)== 
10
### ==Math.Round(-9.5)==    
10
### ==Math.Ceiling()== 
向上取整
### ==Math.Floor()==
 向下取整
## 3.String
### ==Length==    
获取字符串长度
### ==ToUpper()/ToLower()==
### ==String.Contact()==   
 连接字符串
```
string myString = "Hello";
Console.WriteLine(myString[0]); //output:H
```
```
string name = "John Doe";
int charPos = name.IndexOf("D");
string lastName = name.Substring(charPos); //可以指定长度
Console.WriteLine(lastName);
```
### ==\\== 
转移符号
## 4.判断&循环
### ==? :==
```
int time = 20;
string result = (time < 18) ? "Good day." : "Good evening.";
Console.WriteLine(result);
// 三元换算符
```
### ==swith...case...==
```
int day = 4;
switch (day) 
{
  case 6:
    Console.WriteLine("Today is Saturday.");
    break;
  case 7:
    Console.WriteLine("Today is Sunday.");
    break;
  default:
    Console.WriteLine("Looking forward to the Weekend.");
    break;
}  
//default 和 break要放在最后
```
### ==For Loop & While Loop & Do...While... & Foreach==
### ==break & continue==
## 5.数组
`string[] cars = {"Volvo", "BMW", "Ford", "Mazda"};`

### ==Sort Arrays==
```
// Sort a string
string[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
Array.Sort(cars);
foreach (string i in cars)
{
  Console.WriteLine(i);
}
 
// Sort an int
int[] myNumbers = {5, 1, 8, 9};
Array.Sort(myNumbers);
foreach (int i in myNumbers)
{
  Console.WriteLine(i);
}
//按升序或字母排序进行排列
```
### ==其他方法：Max()/Min()/Sum()==
### ==多维数组和交错数组==
```
//多维数组：在声明时，必须指定每一维的长度
int[,] mda = new int[2, 3];
mda[0, 0] = 1;
mda[0, 1] = 2;
Console.WriteLine(mda.Length);   //6
Console.WriteLine(mda.Rank);     //2
Console.WriteLine(mda.GetLength(0));  //2，一维的长度
int[,] mda = { { 1, 2, 3 }, { 4, 5, 6 } }; 

//交错数组：声明时，至少需要指定第一维的长度
int [][] test = new int[5][];　
```
### ==声明数组的几种方式==
```
// Create an array of four elements, and add values later
string[] cars = new string[4];

// Create an array of four elements and add values right away 
string[] cars = new string[4] {"Volvo", "BMW", "Ford", "Mazda"};

// Create an array of four elements without specifying the size 
string[] cars = new string[] {"Volvo", "BMW", "Ford", "Mazda"};

// Create an array of four elements, omitting the new keyword, and without specifying the size
string[] cars = {"Volvo", "BMW", "Ford", "Mazda"};

//通常选择最后一个
```
## 6.Method
### ==可选参数==
```
static void MyMethod(string country = "Norway") 
{
  Console.WriteLine(country);
}
//无参数时输出Norway
//可选参数必须定义在不可选参数的后面
```
### ==命名参数==
```
static void MyMethod(string child1 = "Liam", string child2 = "Jenny", string child3 = "John")
{
  Console.WriteLine(child3);
}

static void Main(string[] args)
{
  MyMethod(child3:"我是命名参数");
}
```
命名参数一般结合可选参数一起使用
## 7.零碎知识点
### ==项目组织==
```
1.一个project对应一个文件夹，下面有一个.csproj文件，记录该project下面包含的各种文件以及其他配置；
2. .obj放中间代码（调试用信息）,.bin放最终代码（编译后信息）；
3.///自动生成方法注释；
```
### ==表达式主体定义==
```
如果方法只有一条return语句，可以写成:
static int Add(int a, int b) => a + b;
上面语句等价于:
static int Add(int a, int b) 
{ 
  return a + b;
}
```
### ==ref和out==
```
1.ref:
i、方法定义和调用方法都必须显式使用 ref 关键字
ii、传递到 ref 参数的参数必须初始化,否则程序会报错
iii、通过ref的这个特性,一定程度上解决了C#中的函数只能有一个返回值的问题
```
```
static void Main(string[] args)
{
  int a = 6;
  int b = 66;
  Fun(ref a,ref b);
  Console.WriteLine("a:{0},b:{1}", a, b);//输出:72和6说明传入Fun方法是a和b的引用
}
static void Fun(ref int a, ref int b) 
{
  a = a+b;  //72,说明Main方法的a和b的值传进来了
  b = 6;
}
```
```
2.out:
和ref类似，定义和调用都必须显示使用out关键字；
区别是无法传值到方法中，所以赋值无意义。
```
```
static void Main(string[] args)
{
  int a = 6;
  int b = 66;
  Fun(ref a,ref b);
  Console.WriteLine("a:{0},b:{1}", a, b);//输出:72和6说明传入Fun方法是a和b的引用
}
static void Fun(ref int a, ref int b) 
{
  a = a+b;  //72,说明Main方法的a和b的值传进来了
  b = 6;
}
----------------------------------------------------------------------
out常用于一个方法需要多个返回的时候（即：获取除了返回值以外的结果），比如类库中的TryParse：
//如果能够Parse，方法返回值为true，input为转换结果
//否则，方法返回值为false，input为默认值0
if (double.TryParse(Console.ReadLine(), out double input))
{
  input += 10;
}
else
{
  Console.WriteLine("输入错误……");
}
```
### ==default()表达式==
`
default(int)
`
### ==params==
```
当方法的参数是数组的时候，我们可以在数组类型前面加一个关键字params：
static void getMax(params int[] array)
调用时，就可以直接传递数组元素：
getMax(3, 9, 18, 23);
```
### ==名称空间别称==
`
using yz = _17bang.feige.YuanZhan;
`

# 面向对象  
### ==OOP(Object-Oriented-Programming)==      
``
"Don't Repeat Yourself" (DRY)  
`` 
``
a class is a template for objects, and an object is an instance of a class.
``
### ==Constructor==
```
1.没有返回类型
2.所有类默认自带一个Constructor，new的时候就是在调用构造函数
3.构造函数可以带参数（给字段赋值）有重载
this.name=name;
4.给字段赋值，减少代码量
5.一旦声明了任何构造函数，之前默认自带的无参构造函数消失
--------------------------------------------------------------------
this在复制构造函数时的作用:
public Student(string name)   // 构造函数 1
{
    this.name = name;
}

public Student(string name, int age)
    : this(name)   // 使用this()调用构造函数 1
{
    this.age = age;
}
当运行Student(name, age)之前，会首先运行Student(name)
```
### ==Access Modifiders==
```
public
private 类不能使用private，且默认修饰符是internal
protected
internal  内部的，可以在当前项目中使用
protected internal  子类/跨项目的子类可使用
privated internal
//所有类成员默认private
```
### ==Encapsulation==
```
declare fields/variables as private
provide public get and set methods, through properties, to access and update the value of a private field

-Why Use?
1.Better control of class members (reduce the possibility of yourself (or others) to mess up the code)
2.Fields can be made read-only (if you only use the get method), or write-only (if you only use the set method)
3.Flexible: the programmer can change one part of the code without affecting other parts
4.Increased security of data
```
### ==Properties==
```
class Person
{
  private string name; // field

  public string Name   // property
  {
    get { return name; }   // get method
    set { name = value; }  // set method
  }
}
```
### ==readonly & const==
```
区别：
1.const一旦声明，就要赋值；readonly可用延后到constructor
2.const只能是int/bool/string等基本类型；readonly可以是其他类型（如Teacher）
3.const默认static，由类名直接调用；readonly默认是实例成员，由对象调用
4.const还可用于方法体内修饰变量，readonly不行
5.const是在编译时完成赋值，而readonly是在运行时赋值
```
### ==sealed==
### ==匿名类==
```
既没有类目，也不需要声明，可以直接使用的类：
var zjq = new  
{
    Name = "曾俊清",
    Age = 23,
};
语法特点：
1.变量类型只能用var；
2.所有属性只能是只读；
3.只是匿名，本质还是一个“类”，编译时会给名字<AnonymousType>；
4.拥有相同（名称+类型+次序）属性的匿名类会被当做一个类。
```
### ==索引器==
```
用于封装具有多个元素的数组
1.声明字段保存数据：
private string[] _courses={"SQL"."C#","JavaScript"}
2.可以指定访问修饰符，需要指定返回类型：
public string this[int index]
{
  get {return _courses[index;]}
  set {_courses[index]=value;}
}
3.调用时用[]
```
### ==析构函数==
```
1.~开头；
2.在.NET运行时在垃圾回收（garbage collection）时自动调用；
3.垃圾回收：清除内存上存放的数据，以便再次被使用；
4.值类型变量会在出栈时被清空；引用类型变量不会自动清除，会造成内存泄漏；
5.GC.Collect() 强制垃圾回收，否则因为可用内存足够大，不一定会被回收。
```
### ==静态和实例==
```
1.静态构造函数：
internal class Student
{
    static Student()   //不能有访问修饰符，也不能有参数
    {
    }
}
因为静态构造函数不能被开发人员调用，只能由.NET运行时在使用类之前，自动调用一次且仅仅调用一次。所以访问修饰符和参数对它都没有意义。

2.静态类
static；
静态类不能被实例化，不能有实例成员(实例类可以有静态成员)
```
### ==继承==
```
:
C#不支持多重继承，支持多层继承；
实例化一个子类，需要调用所有父类的构造函数；
如果父类只有一个无参构造函数，会默认调用这个无参构造函数，若父类没有无参构造函数，就需要在子类的构造函数中指明具体调用父类的哪一个构造函数；
如下:
internal class Person
{
    //父类没有无参构造函数
    public Person(string name) { }
    internal string Name { get; set; }
}

internal class Student : Person
{
    //子类必须显式地指明调用父类的某一个构造函数
    public Student(string name)
      : base(name)   //使用base关键字，将子类实例化获得的name传递给父类
    //: base("飞哥") //也可以传一个固定值 
    { 

    }
}
```
### ==is & as==
`
用来判断继承关系
`
### ==Polymorphism==
```
class Animal  // Base class (parent) 
{
  public void animalSound() 
  {
    Console.WriteLine("The animal makes a sound");
  }
}

class Pig : Animal  // Derived class (child) 
{
  public void animalSound() 
  {
    Console.WriteLine("The pig says: wee wee");
  }
}

class Dog : Animal  // Derived class (child) 
{
  public void animalSound() 
  {
    Console.WriteLine("The dog says: bow wow");
  }
}

class Program 
{
  static void Main(string[] args) 
  {
    Animal myAnimal = new Animal();  // Create a Animal object
    Animal myPig = new Pig();  // Create a Pig object
    Animal myDog = new Dog();  // Create a Dog object

    myAnimal.animalSound();
    myPig.animalSound();
    myDog.animalSound();
  }
}
output:
The animal makes a sound
The animal makes a sound
The animal makes a sound
```
### ==new==
```
可以用new来掩盖父类方法:
internal class Student : Person
{
  internal new void Eat()         //注意关键字new
  {
     Console.WriteLine("学生吃饭");
  }  
}
```
### ==override(重写)==
```
class Animal  // Base class (parent) 
{
  public virtual void animalSound() 
  {
    Console.WriteLine("The animal makes a sound");
  }
}

class Pig : Animal  // Derived class (child) 
{
  public override void animalSound() 
  {
    Console.WriteLine("The pig says: wee wee");
  }
}

class Dog : Animal  // Derived class (child) 
{
  public override void animalSound() 
  {
    Console.WriteLine("The dog says: bow wow");
  }
}

class Program 
{
  static void Main(string[] args) 
  {
    Animal myAnimal = new Animal();  // Create a Animal object
    Animal myPig = new Pig();  // Create a Pig object
    Animal myDog = new Dog();  // Create a Dog object

    myAnimal.animalSound();
    myPig.animalSound();
    myDog.animalSound();
  }
}
output:
The animal makes a sound
The pig says: wee wee
The dog says: bow wow

子类可以用base调用父类的方法，示例如下：
internal class Student : Person
{
  internal override void Eat()   //这里已经是override了
  {
    Console.WriteLine("学生吃饭");
  }
}

internal class AgileStudent : Student
{
  internal override void Eat()  //继续override
  {
     base.Eat();                //base仅指Student，不包含父类的父类
  }
}
```
### ==Abstraction==
```
1.作用于类，不能被实例化；
2.作用于方法，没有方法体；
3.抽象方法只能放置在被abstract修饰的抽象类中；
4.可以声明其他普通类成员，包括构造函数；
5.子类需要override实现抽象类的全部抽象方法且override的方法体内不能通过base调用其抽象类方法；
6.目的:To achieve security - hide certain details and only show the important details of an object.
```
### ==Interface==
```
1.只能有声明(方法和属性)，不能有实现；
2.不能有字段和构造函数；
3.接口类型可以加访问修饰符，接口成员不能有访问修饰符；
4.一个子类要实现接口，需要实现接口的全部成员(包括继承的接口的所有成员)
```
```
实现接口的两种方式：
1.隐式实现：在子类中添加和接口中定义相同的方法
internal class Student : Person, ILearn
{
  //ILearn中定义了一个Practise()方法
  public void Practise()
  {
    //实现了ILearn中定义的Practise()方法
     Console.WriteLine("键盘敲烂，月薪过万！");
  }
}
2.显示实现：当一个子类继承了多个接口，且多个接口中定义了相同方法
internal class Student : Person, ILearn, IPlay
{
  //internal void ILearn.Practise()  //不能有访问修饰符
  void ILearn.Practise()  //实现ILearn.Practise()方法
  {
     Console.WriteLine("键盘敲烂，月薪过万！");
  }

  void IPlay.Practise()  //实现IPlay.Practise()方法
  {
     Console.WriteLine("再撸一把啊！");
  }
}
// 显式实现的接口方法，不能用子类类型的变量进行调用：
```
### ==抽象类和接口的异同==
```
语法层面:
1.抽象类可以有其他实现，接口只能有声明；
2.抽象类可以继承接口，接口无法继承抽象类；
3.抽象类只能作为父类使用，所以一个子类只能有继承一个抽象类，但能有多个接口；
现实意义：
抽象类是对现实事物的映射，一般类目时名词；
接口是对事物行为的封装，一般接口名是动词。
```
### ==接口和日期==
```
Struct
1.能够实现接口，但不能继承其他结构和类；也不能被其他结构和类继承；
2.默认有一个无参构造函数，但不能显示声明，有参构造函数可以显示声明，声明的有参构造函数不会"隐藏"默认的无参构造函数；
3.所有成员必须有值,若使用结构默认的无参构造函数，结构弧自动给所有成员赋值默认值

DateTime
1.ToString()，用于指定日期显示的格式-yyyy年MM月dd日 hh点mm分ss秒；
2.TimeSpan
表示一段时间，通常由两个日期相减获得，最大单位-天，没有年和月；
用Days/Hours/Minutes等取出的是Timespan中天/小时/分钟等部分的值；
用TotalDays/TotalHours/TotalMinutes等取出的才是Timespan代表的时间间隔换算成天/小时/分钟等的值。
```
### ==运算符重载 & 类型转换重载
```
运算符重载:
public static DateTime operator +(DateTime d, TimeSpan t);
1.方法只能是public和static；
2.必须要有一个关键字operator；
3.至少一个参数和返回值类型相匹配；

```
### ==Enum & 位运算==
```
enum Level 
{
  Low,
  Medium,
  High
}
//Level.Medium
//默认从0开始，步长为1
//需要在枚举和整型之间强制转换
```
一般与switch相结合:
```
enum Level 
{
  Low,
  Medium,
  High
}

static void Main(string[] args) 
{
  Level myVar = Level.Medium;
  switch(myVar) 
  {
    case Level.Low:
      Console.WriteLine("Low level");
      break;
    case Level.Medium:
       Console.WriteLine("Medium level");
      break;
    case Level.High:
      Console.WriteLine("High level");
      break;
  }
}
```
```
位运算：把传入的数转化成二进制，然后按二进制对其进行运算
1.&:位与，只有两个1才为1；
2.|:位或，只要一个1就位1；
3.^:异或，两个不同才为1；
```
### ==Files==
`The File class from the System.IO namespace, allows us to work with files`
##### ==Methods==
---------------------------
Method | Desciption
------ | ------
AppendText() | Appends text at the end of an existing file
Copy() | Copies a file
Create() | Creates or overwrites a file
Create() | Creates or overwrites a file
Delete() | Deletes a file
Exists() |	Tests whether the file exists
ReadAllText() |	Reads the contents of a file
Replace()	| Replaces the contents of a file with the contents of another file
WriteAllText() |	Creates a new file and writes the contents to it. If the file already exists, it will be overwritten.
#### ==Example==
```
using System.IO;  // include the System.IO namespace

string writeText = "Hello World!";  // Create a text string
File.WriteAllText("filename.txt", writeText);  // Create a file and write the content of writeText to it

string readText = File.ReadAllText("filename.txt");  // Read the contents of the file
Console.WriteLine(readText);  // Output the content
```
### ==Exceptions==
#### ==try...catch...finally==
```
try
{
  int[] myNumbers = {1, 2, 3};
  Console.WriteLine(myNumbers[10]);
}
catch (Exception e)
{
  Console.WriteLine(e.Message);
}
finally
{
  Console.WriteLine("The 'try catch' is finished.");
}
```
#### ==throw==
```
static void checkAge(int age)
{
  if (age < 18)
  {
    throw new ArithmeticException("Access denied - You must be at least 18 years old.");
  }
  else
  {
    Console.WriteLine("Access granted - You are old enough!");
  }
}

static void Main(string[] args)
{
  checkAge(15);
}
```